<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SVD · ACS.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ACS.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../prep/">Preparation</a></li><li class="is-active"><a class="tocitem" href>SVD</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#How?"><span>How?</span></a></li><li><a class="tocitem" href="#Practical-example"><span>Practical example</span></a></li><li><a class="tocitem" href="#Applications"><span>Applications</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SVD</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SVD</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EMCMS/ACS.jl/blob/main/docs/src/svd.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Singular-Value-Decomposition-(SVD)"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition-(SVD)">Singular Value Decomposition (SVD)</a><a id="Singular-Value-Decomposition-(SVD)-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition-(SVD)" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition"><strong>SVD</strong></a> is a matrix factorization technique that decomposes any matrix to a unique set of matices. The <strong>SVD</strong> is used for dimension reduction, trend analysis, and potentially for the clustering of a multivariate dataset. <strong>SVD</strong> is an exploratory approach to the data analysis and therefore it is an unsuprevised approach. In other words, you will only need the <em>X</em> block matrix. However, where the <em>Y</em> matrix/vector is available, it (i.e. <em>Y</em>) can be used for building composit models or assess the quality of the clustering. </p><h2 id="How?"><a class="docs-heading-anchor" href="#How?">How?</a><a id="How?-1"></a><a class="docs-heading-anchor-permalink" href="#How?" title="Permalink"></a></h2><p>In <strong>SVD</strong> the matrix <em>X_{m \times n}</em> is decomposed into the matrices <em>``U_{m \times n}</em>, <em>D_{n \times n}``</em>, and <em><span>$V_{n \times n}^{T}$</span></em>. The matrix <em><span>$U_{m \times n}$</span></em> is the left singular matrix and it represents a rotation in the matrix space. The <em><span>$D_{n \times n}$</span></em> is diagonal matrix and contains the singular values. This matix may be indicated with different symbols such as <em><span>$\Sigma_{n \times n}$</span></em>. The <em><span>$D_{n \times n}$</span></em> matrix in the geometrical space represents an act of stratching. Each <em>singular value</em> is the degree and/or weight of stratching. We use the notation <em><span>$D_{n \times n}$</span></em> to remind ourselves that this is a diagonal matrix. Finally, <em><span>$V_{n \times n}^{T}$</span></em> is called the right singular matrix and is associated with rotation. Overall, <strong>SVD</strong> geometrically is a combination of a rotation, a stratching, and a second rotation.</p><p>The two matrics <em><span>$U_{m \times n}$</span></em> and <em><span>$V_{n \times n}^{T}$</span></em> are very special due to their <a href="https://en.wikipedia.org/wiki/Unitary_matrix">unitary</a> properties.</p><p class="math-container">\[
U^{T} \times U = U \times U^{T} = I\\
V^{T} \times V = V \times V^{T} = I
\]</p><p>Therefore the general matrix expression of <strong>SVD</strong> is the following: </p><p class="math-container">\[X = UDV^{T}.
\]</p><p>To deal with the non-square matrices, we have to convert our <em>X</em> matrix to <span>$X^{T} \times X$</span>. This implies that our <strong>SVD</strong> equation will become the following: </p><p class="math-container">\[X^{T}X = (UDV^{T})^{T} \times UDV^{T}.
\]</p><p>And after a little bit of linear algebra: </p><p class="math-container">\[X^{T}X = VD^{T} \times DV^{T} \\ 
and \\

XV = UD.
\]</p><p>This is a system of two equations with two variables that can be solved. Before looking at an example of such system let&#39;s remind ourselves that <span>$VD^{T} \times DV^{T}$</span> is the solution of <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">eigenvalue/eigenvector decomposition</a> of <span>$X^{T}X$</span>. This means that both <em>D</em> and <em><span>$V^{T}$</span></em> can be calculated by calculating the <a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eigenvalues and eigenvectors</a> of <span>$X^{T}X$</span>. Therefore we can calculate <em>D</em> and <em>V</em> as follows:</p><p class="math-container">\[
D = \sqrt{eigenvalues(X^{T}X)}\\ 
V = eigenvector(X^{T}X).
\]</p><p>Once we know <em>V</em>, we can use that and the second equation of SVD to calculate the last part i.e. the matrix <em>U</em>. </p><p class="math-container">\[U = XVD^{-1} 
\]</p><p>Please note that <span>$D^{-1}$</span> denotes the <a href="https://en.wikipedia.org/wiki/Invertible_matrix">inverse or pseudo-inverse</a> of the matrix <em>D</em>.  </p><h2 id="Practical-example"><a class="docs-heading-anchor" href="#Practical-example">Practical example</a><a id="Practical-example-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-example" title="Permalink"></a></h2><p>Let&#39;s do the <strong>SVD</strong> calculations together for the below matrix: </p><pre><code class="language-julia hljs">using ACS

X = [5 -5;-1 7;1 10]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Int64}:
  5  -5
 -1   7
  1  10</code></pre><h3 id="Step-1:-X{T}X"><a class="docs-heading-anchor" href="#Step-1:-X{T}X">Step 1: <span>$X^{T}X$</span></a><a id="Step-1:-X{T}X-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-X{T}X" title="Permalink"></a></h3><pre><code class="language-julia hljs"># The function transpose(-) is part of LinearAlgebra.jl package that has been automatically installed via ACS.jl package.
# Not all the functions of LinearAlgebra.jl are exported within the ACS.jl enviornment.
XtX = transpose(X)*X</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Int64}:
  27  -22
 -22  174</code></pre><h3 id="Step-2:-calculation-of-*D*,-*V*,-and-*U*"><a class="docs-heading-anchor" href="#Step-2:-calculation-of-*D*,-*V*,-and-*U*">Step 2: calculation of <em>D</em>, <em>V</em>, and <em>U</em></a><a id="Step-2:-calculation-of-*D*,-*V*,-and-*U*-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-calculation-of-*D*,-*V*,-and-*U*" title="Permalink"></a></h3><pre><code class="language-julia hljs">D = diagm(sqrt.(eigvals(XtX))) # A diagonal matrix is generated</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 4.87628   0.0
 0.0      13.3125</code></pre><pre><code class="language-julia hljs">V = eigvecs(XtX) # Right singular matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 -0.989446  -0.144904
 -0.144904   0.989446</code></pre><pre><code class="language-julia hljs">U = X*V*pinv(D)	# Left singular matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Float64}:
 -0.865969    -0.426048
 -0.00510321   0.531158
 -0.500072     0.732362</code></pre><h4 id="Builtin-function"><a class="docs-heading-anchor" href="#Builtin-function">Builtin function</a><a id="Builtin-function-1"></a><a class="docs-heading-anchor-permalink" href="#Builtin-function" title="Permalink"></a></h4><p>The same calculations can be done with the fucntion <em>svd(-)</em> of ACS package provided via LinearAlgebra.jl package. </p><pre><code class="language-julia hljs"> out = svd(X)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearAlgebra.SVD{Float64, Float64, Matrix{Float64}}
U factor:
3×2 Matrix{Float64}:
  0.426048  0.865969
 -0.531158  0.00510321
 -0.732362  0.500072
singular values:
2-element Vector{Float64}:
 13.312471610995619
  4.8762792789621585
Vt factor:
2×2 Matrix{Float64}:
 0.144904  -0.989446
 0.989446   0.144904</code></pre><pre><code class="language-julia hljs"> D = diagm(out.S) # The singular value matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 13.3125  0.0
  0.0     4.87628</code></pre><pre><code class="language-julia hljs"> U = out.U # Left singular matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Float64}:
  0.426048  0.865969
 -0.531158  0.00510321
 -0.732362  0.500072</code></pre><pre><code class="language-julia hljs"> V = transpose(out.Vt) # Right singular matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 transpose(::Matrix{Float64}) with eltype Float64:
  0.144904  0.989446
 -0.989446  0.144904</code></pre><p>Please note that the builtin function sorts the singular values in descending order and consequently the other two matrices are also sorted following the same. Additionally, for ease of calculations the builtin function generates the mirror image of the <em>U</em> and <em>V</em> matrices. These differences essentially do not impact your calculations at all, as long as they are limited to what is listed above.</p><h3 id="Step-3-calculation-of-\\hat{X}"><a class="docs-heading-anchor" href="#Step-3-calculation-of-\\hat{X}">Step 3 calculation of <span>$\hat{X}$</span></a><a id="Step-3-calculation-of-\\hat{X}-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3-calculation-of-\\hat{X}" title="Permalink"></a></h3><p>Using both the manual method and the builtin function, you can calculate <span>$\hat{X}$</span> following the below operation. </p><pre><code class="language-julia hljs">X_hat = U*D*transpose(V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Float64}:
  5.0  -5.0
 -1.0   7.0
  1.0  10.0</code></pre><h2 id="Applications"><a class="docs-heading-anchor" href="#Applications">Applications</a><a id="Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Applications" title="Permalink"></a></h2><p>As mentioned above <strong>SVD</strong> has several applications in different fields. Here we will focus on three, namely: dimension reduction, clustering/trend analysis, and multivariate regression. </p><h3 id="Dimension-reduction"><a class="docs-heading-anchor" href="#Dimension-reduction">Dimension reduction</a><a id="Dimension-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-reduction" title="Permalink"></a></h3><p>To show case the power of <strong>SVD</strong> in dimension reduction we will use the <em>Iris</em> dataset from <a href="https://github.com/JuliaStats/RDatasets.jl">Rdatasets</a>. </p><pre><code class="language-julia hljs">using ACS

data = dataset(&quot;datasets&quot;, &quot;iris&quot;)
describe(data) # Simerizes the dataset</code></pre><div class="data-frame"><p>5 rows × 7 columns</p><table class="data-frame"><thead><tr><th></th><th>variable</th><th>mean</th><th>min</th><th>median</th><th>max</th><th>nmissing</th><th>eltype</th></tr><tr><th></th><th title="Symbol">Symbol</th><th title="Union{Nothing, Float64}">Union…</th><th title="Any">Any</th><th title="Union{Nothing, Float64}">Union…</th><th title="Any">Any</th><th title="Int64">Int64</th><th title="DataType">DataType</th></tr></thead><tbody><tr><th>1</th><td>SepalLength</td><td>5.84333</td><td>4.3</td><td>5.8</td><td>7.9</td><td>0</td><td>Float64</td></tr><tr><th>2</th><td>SepalWidth</td><td>3.05733</td><td>2.0</td><td>3.0</td><td>4.4</td><td>0</td><td>Float64</td></tr><tr><th>3</th><td>PetalLength</td><td>3.758</td><td>1.0</td><td>4.35</td><td>6.9</td><td>0</td><td>Float64</td></tr><tr><th>4</th><td>PetalWidth</td><td>1.19933</td><td>0.1</td><td>1.3</td><td>2.5</td><td>0</td><td>Float64</td></tr><tr><th>5</th><td>Species</td><td></td><td>setosa</td><td></td><td>virginica</td><td>0</td><td>CategoricalValue{String, UInt8}</td></tr></tbody></table></div><h3 id="Clustering-and-trend-analysis"><a class="docs-heading-anchor" href="#Clustering-and-trend-analysis">Clustering and trend analysis</a><a id="Clustering-and-trend-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-and-trend-analysis" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../prep/">« Preparation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Friday 22 July 2022 16:25">Friday 22 July 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
